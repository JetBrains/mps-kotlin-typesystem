package jetbrains.mps.kotlin.test.hierarchy;

/*Generated by MPS */

import jetbrains.mps.MPSLaunch;
import jetbrains.mps.lang.test.runtime.BaseTransformationTest;
import org.junit.jupiter.api.extension.RegisterExtension;
import jetbrains.mps.lang.test.runtime.TestParametersCacheExtension;
import jetbrains.mps.lang.test.runtime.TestParametersCache;
import org.junit.jupiter.api.Test;
import jetbrains.mps.lang.test.runtime.BaseTestBody;
import jetbrains.mps.lang.test.runtime.TransformationTest;
import org.junit.Assert;
import jetbrains.mps.logic.reactor.evaluation.EvaluationFailureException;
import jetbrains.mps.kotlinExt.types.AncestorFinder;
import jetbrains.mps.kotlin.api.types.identifiers.FunctionType;
import java.util.Set;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import jetbrains.mps.logic.dataform.DataForm;
import jetbrains.mps.internal.collections.runtime.SetSequence;
import org.jetbrains.mps.openapi.model.SNode;
import java.util.List;
import jetbrains.mps.kotlin.api.types.identifiers.TypeKey;
import jetbrains.mps.kotlin.behavior.IClassLike__BehaviorDescriptor;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.kotlin.behavior.IType__BehaviorDescriptor;

@MPSLaunch
public class AncestorFinders_Test extends BaseTransformationTest {
  @RegisterExtension
  private static final TestParametersCacheExtension ourParametersCacheExtension = new TestParametersCacheExtension(new TestParametersCache(AncestorFinders_Test.class, "${kotlin_home}", "r:38084a08-bc59-4dbd-86a4-7236d93dab64(jetbrains.mps.kotlin.test.hierarchy@tests)", false));

  public AncestorFinders_Test() {
    super(ourParametersCacheExtension.getParametersCache());
  }

  @Test
  public void test_lookupInvalid() throws Throwable {
    new TestBody(this).test_lookupInvalid();
  }
  @Test
  public void test_lookupExisting() throws Throwable {
    new TestBody(this).test_lookupExisting();
  }
  @Test
  public void test_lookupFunctionType() throws Throwable {
    new TestBody(this).test_lookupFunctionType();
  }
  @Test
  public void test_commonSuperTypes() throws Throwable {
    new TestBody(this).test_commonSuperTypes();
  }

  /*package*/ static class TestBody extends BaseTestBody {

    /*package*/ TestBody(TransformationTest owner) {
      super(owner);
    }

    @Override
    protected void initTestNodes() {
      prepareTestNodes("5410850268120684862");
    }

    public void test_lookupInvalid() throws Exception {
      initTestNodes();
      runWithinCommand(() -> {
        try {
          TestBody.this.lookupOnFinder(getAnnotatedNode("self"), getAnnotatedNode("external"));
          Assert.fail();
        } catch (EvaluationFailureException e) {
          // expected exception
        }
      });
    }
    public void test_lookupExisting() throws Exception {
      initTestNodes();
      runWithinCommand(() -> TestBody.this.lookupOnFinder(getAnnotatedNode("self"), getAnnotatedNode("second"), getAnnotatedNode("intermediate"), getAnnotatedNode("root"), getAnnotatedNode("parent"), getAnnotatedNode("self")));
    }
    public void test_lookupFunctionType() throws Exception {
      initTestNodes();
      runWithinCommand(() -> {
        AncestorFinder finder = TestBody.this.createFinder(getAnnotatedNode("self"));
        finder.lookup(new FunctionType(2));
        try {
          finder.lookup(new FunctionType(0));
          Assert.fail();
        } catch (EvaluationFailureException e) {
          // expected exception
        }
      });
    }
    public void test_commonSuperTypes() throws Exception {
      initTestNodes();
      runWithinCommand(() -> {
        AncestorFinder selfFinder = TestBody.this.createFinder(getAnnotatedNode("self"));
        AncestorFinder otherFinder = TestBody.this.createFinder(getAnnotatedNode("external"));

        // Test that result is same both ways
        Set<Tuples._2<DataForm, DataForm>> selfOtherCommon = selfFinder.commonSuperTypes(otherFinder);
        Set<Tuples._2<DataForm, DataForm>> otherSelfCommon = otherFinder.commonSuperTypes(selfFinder);

        // 2: Any from [Self, Parent, Any], IntermediateInterface from [Self, IntermediateInterface, ...]
        Assert.assertEquals(2, SetSequence.fromSet(otherSelfCommon).count());
        Assert.assertEquals(SetSequence.fromSet(otherSelfCommon).count(), SetSequence.fromSet(selfOtherCommon).count());
      });
    }

    public AncestorFinder createFinder(SNode type) {
      Tuples._2<List<List<TypeKey>>, List<SNode>> paths = AncestorFinder.buildPaths(IClassLike__BehaviorDescriptor.getThisType_id46gC9M6gB68.invoke(type));
      AncestorFinder finder = new AncestorFinder(paths._0());
      for (List<TypeKey> nodePath : ListSequence.fromList(paths._0())) {
        for (TypeKey typeKey : ListSequence.fromList(nodePath)) {
          finder.declareMapping(typeKey, new TestDataForm(typeKey));
        }
      }
      return finder;
    }
    public void lookupOnFinder(SNode self, SNode... superTypes) {
      AncestorFinder finder = this.createFinder(self);
      for (SNode seeked : superTypes) {
        finder.lookup(IType__BehaviorDescriptor.typeKey_idJmO2PmZtH5.invoke(IClassLike__BehaviorDescriptor.getThisType_id46gC9M6gB68.invoke(seeked)));
      }
    }
  }
}
