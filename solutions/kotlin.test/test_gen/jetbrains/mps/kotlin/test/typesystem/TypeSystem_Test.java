package jetbrains.mps.kotlin.test.typesystem;

/*Generated by MPS */

import jetbrains.mps.MPSLaunch;
import jetbrains.mps.lang.test.runtime.BaseTransformationTest;
import org.junit.jupiter.api.extension.RegisterExtension;
import jetbrains.mps.lang.test.runtime.TestParametersCacheExtension;
import jetbrains.mps.lang.test.runtime.TestParametersCache;
import org.junit.jupiter.api.Test;
import jetbrains.mps.lang.test.runtime.BaseTestBody;
import jetbrains.mps.lang.test.runtime.TransformationTest;
import org.jetbrains.mps.openapi.persistence.PersistenceFacade;
import org.jetbrains.mps.openapi.model.SModelReference;
import java.util.List;
import jetbrains.mps.baseLanguage.tuples.runtime.Tuples;
import org.jetbrains.mps.openapi.model.SNode;
import jetbrains.mps.internal.collections.runtime.ListSequence;
import jetbrains.mps.baseLanguage.closures.runtime.Wrappers;
import org.jetbrains.mps.openapi.model.SModel;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SPointerOperations;
import jetbrains.mps.lang.smodel.generator.smodelAdapter.SModelOperations;
import jetbrains.mps.internal.collections.runtime.IListSequence;
import java.util.ArrayList;
import jetbrains.mps.coderules.typechecking.service.TypecheckingTestHelper;
import jetbrains.mps.baseLanguage.tuples.runtime.MultiTuple;
import org.junit.Assert;
import jetbrains.mps.internal.collections.runtime.IterableUtils;
import jetbrains.mps.ide.httpsupport.runtime.base.HttpSupportUtil;

@MPSLaunch
public class TypeSystem_Test extends BaseTransformationTest {
  @RegisterExtension
  private static final TestParametersCacheExtension ourParametersCacheExtension = new TestParametersCacheExtension(new TestParametersCache(TypeSystem_Test.class, "${kotlin_home}", "r:075f8e94-5ac7-48fe-90f0-460c8035f853(jetbrains.mps.kotlin.test.typesystem@tests)", false));

  public TypeSystem_Test() {
    super(ourParametersCacheExtension.getParametersCache());
  }

  @Test
  public void test_samples() throws Throwable {
    new TestBody(this).test_samples();
  }
  @Test
  public void test_sandboxSamples() throws Throwable {
    new TestBody(this).test_sandboxSamples();
  }
  @Test
  public void test_interopJava() throws Throwable {
    new TestBody(this).test_interopJava();
  }
  @Test
  public void test_interopKt() throws Throwable {
    new TestBody(this).test_interopKt();
  }
  @Test
  public void test_muted() throws Throwable {
    new TestBody(this).test_muted();
  }

  /*package*/ static class TestBody extends BaseTestBody {

    /*package*/ TestBody(TransformationTest owner) {
      super(owner);
    }

    @Override
    protected void initTestNodes() {
      prepareTestNodes();
    }

    public void test_samples() throws Exception {
      initTestNodes();
      runWithinCommand(() -> TestBody.this.testModelAndReport(PersistenceFacade.getInstance().createModelReference("r:b7a5ae3c-bdb9-4ed4-88cc-db36937f4170(jetbrains.mps.kotlin.test.data)")));
    }
    public void test_sandboxSamples() throws Exception {
      initTestNodes();
      runWithinCommand(() -> TestBody.this.testModelAndReport(PersistenceFacade.getInstance().createModelReference("r:d5925e70-8a29-4d14-898a-c84f3d8155ee(jetbrains.mps.kotlin.sandbox.samples)")));
    }
    public void test_interopJava() throws Exception {
      initTestNodes();
      runWithinCommand(() -> TestBody.this.testModelAndReport(PersistenceFacade.getInstance().createModelReference("r:1ec7802f-ecd7-4be0-a705-ad81d6714142(jetbrains.mps.kotlin.test.interop.fromJava)")));
    }
    public void test_interopKt() throws Exception {
      initTestNodes();
      runWithinCommand(() -> TestBody.this.testModelAndReport(PersistenceFacade.getInstance().createModelReference("r:00d77b6d-6812-41ab-b775-547e9c59d223(jetbrains.mps.kotlin.test.interop.fromKotlin)")));
    }
    public void test_muted() throws Exception {
      initTestNodes();
      runWithinCommand(() -> {
        // This model is designed to contains "muted" failures. In the sense that there should be no errors but while we work on fixing them, the samples are kept there
        final int EXPECTED_ERRORS = 7;
        SModelReference model = PersistenceFacade.getInstance().createModelReference("r:75182e84-62b9-4981-9d50-efcf66fb915c(jetbrains.mps.kotlin.test.muted)");
        List<Tuples._2<SNode, String>> errors = TestBody.this.testModel(model);

        if (ListSequence.fromList(errors).count() != EXPECTED_ERRORS) {
          TestBody.this.report(errors, model.getName().getSimpleName() + " (expected to contain " + EXPECTED_ERRORS + " errors, got " + ListSequence.fromList(errors).count() + "). Please verify or update error number.");
        }
      });
    }

    public List<Tuples._2<SNode, String>> testModel(final SModelReference model) {
      final Wrappers._T<List<SNode>> roots = new Wrappers._T<List<SNode>>();
      final Wrappers._T<SModel> actualModel = new Wrappers._T<SModel>();
      myProject.getRepository().getModelAccess().runReadAction(() -> {
        actualModel.value = SPointerOperations.resolveModel(model, myProject.getRepository());
        roots.value = SModelOperations.roots(actualModel.value, null);
      });

      IListSequence<Tuples._2<SNode, String>> errors = ListSequence.fromList(new ArrayList<Tuples._2<SNode, String>>());
      for (SNode root : ListSequence.fromList(roots.value)) {
        try {
          // No need to retrieve the result
          TypecheckingTestHelper.ofNode(root, myProject).checkTypes();
        } catch (AssertionError | RuntimeException err) {
          ListSequence.fromList(errors).addElement(MultiTuple.<SNode,String>from(root, err.getMessage().replace(model.toString(), "[model]")));
        }
      }

      return errors;

    }
    public void report(List<Tuples._2<SNode, String>> errors, String modelName) {
      // TODO ideally, we'd have a single test failure per error
      if (ListSequence.fromList(errors).isNotEmpty()) {
        Assert.fail("Error(s) checking model " + modelName + "\n\t" + IterableUtils.join(ListSequence.fromList(errors).select((it) -> it._1() + "\n\t\tsee " + HttpSupportUtil.getURL(it._0())), "\n\t"));
      }
    }
    public void testModelAndReport(SModelReference model) {
      List<Tuples._2<SNode, String>> errors = this.testModel(model);
      this.report(errors, model.getModelName());
    }
  }
}
